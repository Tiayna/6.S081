# 6.S081
MIT OS
先说起因：个人操作系统的学习路线，先通过书籍《2023王道操作系统》考研书速成概念学习；
同时在实际中接触到操作系统方面的问题时查阅相关博客阅览，了解到MIT的一门知名公开课程6.S081，于是着手接触配置环境进行实际实践学习
实验尝试学习是在本人大三上半学年中进行，断断续续的一个多月，在对个人能力评估的基础上完成了11个labs中的6个（util,syscall,pgtbl,trap,lock,fs）
该说明文档简要概述了完成了的labs中的主要代码实现以及部分key要点。

环境配置：实验运行在vscode内置远端拓展wsl(window subsystem of linux)，wsl链接的是在微软商店中下载的ubuntu(20.04)
在ubuntu shell中更新（sudo apt-get update...）后，输入课程官网要求配置安装(Installing via APT)项下的一行代码即可完成实验环境搭建

一：util
第一个实验是用来上手理解代码在底层运行逻辑的，包括父子进程的切换fork、管道的端口输入输出pipe等
1、sleep: 检测输入的同时直接调用系统调用的sleep即可
2、pingpong： 明确管道pipe的两端，父进程从p[1]端写入，子进程从p[0]端读出，注意缓冲区的使用
3、primes： 在数学原理的基础上通过子进程的递归创建new_proc(int p[2])实现，记得对管道进行读写的同时要对另一端close/open
4、find： 底层代码最难读懂的，沿目录树查找的代码仿照实现，通过判断当前stat类型为目录还是文件迭代遍历，直到找到T_FILE；stat.h：类似用于追踪文件类型的数据结构
5、xargs： 用于实现读取多行数据，先记忆标准输入中的第二个参数（系统调用命令，第一个参数为xargs），后再从标准输入中逐个读取输入的参数

二：syscall
第二个实验用于了解系统调用的实现转换以及相应的内核态与用户态的切换，在xv6中添加系统调用的流程以及相关的通过脚本实现的底层转换，还有系统调用通过寄存器传参的argxxx实现
1、system call trace： 实现一个可以追踪想要的系统调用的用户指令，通过位运算记录追踪的mask，在syscall()时，如果是要trace的则将其打印输出
2、sysinfo： 记录系统调用过程中空闲的内存、空闲的进程（学校课程中还要求记录空闲的文件描述符数量），通过宏定义中的NPORC遍历查找空闲进程，通过空闲内存块链表遍历查找空闲内存块实现

三：pgtbl
第三个实验展示了代码实现的内存的分页管理系统，xv6分页管理中的一些数据结构：页表pagetable_t，页表项pte_t；页表项物理地址(44+12)与虚拟地址(44+10)之间的转换，多级页表之间的递归查找
1、print a pagetable： 打印进程使用的页表，xv6的分页管理系统使用的是三级页表结构，即物理地址中的27位用于查找页表项，可通过标志位判断页表项使用情况以及level层级
2、a kernel pagetable per process： 内核中只有一个页表，要实现每个进程都有一份内核页表的拷贝，在进程结构体proc中添加一个新的用户内核页表（全局内核页表的拷贝），
仿照相关的初始化/释放函数，对该拷贝的页表进行对应的初始化和释放，以及相应的切换进程时的全局内核页表切换。（这么实现的目的就是能让内核直接去使用用户指针，而不用全局内核页表进行映射操作）
3、Simplify： 内核的copyin函数在读取用户指针时需要先切换为物理地址，利用2实现的用户内核页表，使copyin可以直接访问用户指针；将用户内核页表指针指向用户页表处即可(kpagetable->pagetable)

四：trap
第四个实验展示了xv6中函数调用的用户栈结构，将进程中的参数存储到寄存器中并用函数栈帧trapframe（基本单位）维护，用户栈结构中的函数调用与被调用关系，以及相应用于记录指示的栈底指针sp、当前栈帧指针fp
1、RISC-V assembly： 一些关于RISC-V指令系统的QA
2、backtrace： 要先了解xv6的用户栈中栈帧的结构关系，知道函数栈帧中返回地址与上一个栈帧的存储相对fp的位置，然后便可递归调用backtrace()回溯至用户栈顶
3、Alarm： xv6周期性的发出警告，可用于限制进程的CPU时间或者周期性调用的操作；通过添加系统调用sigalarm,sigreturn，添加的系统调用在测试程序中经过n个CPU时间片时便会调用对应的handler
作为alarm，同时由于sigalarm系统调用的缘故，寄存器的值必然会出现切换，于是需要提前记录好sigalarm前的栈帧trapframe情况，并在sigreturn中将其恢复

五：lock
第五个实验展示了xv6的锁机制，通过修改xv6的锁机制来提高并行性，减少锁冲突
1、Memory Allocator： 修改内存分配机制，与其让多个CPU共同竞争一个内存空闲块链表，不如为每个CPU单独分配一个kmem，使每个CPU内核使用独立的空闲内存块链表，避免锁冲突的情况，
同时在某个CPU没有空闲内存块时可以偷窃其他CPU的；通过修改kmem为数组（大小为NCPU），以及相应的kalloc/kfree操作来进行对应的空闲内存块分配与释放
2、Buffer cache： xv6中的bcache用于缓存磁盘数据块，仅仅一个bcache很容易在多核的情况下发生锁冲突，通过修改对bcache的访问情况来减少锁冲突；一种方法便是使用哈希表
将数据块号blockno作为key值散列，并为每个哈希桶（质数）bucket分配一个锁，以减少锁冲突（具体实现便是在代码中进行维度上升，并仿照原来的实现）；若不修改NBUF，由于桶的数量，势必需要分配更多的锁，需要修改NLOCK

六：fs
第六个实验展示了xv6的文件管理系统，以及inode链接对应的文件的相应结构，并且实现了大文件的二级数据块表和符号链接（软链接）
1、Large file： 原本的xv6的索引节点inode结构中包含12个直接映射和一个间接映射的数据块索引，最多对应存储12+1024/4个数据块，为了应付大文件，将inode中的addrs[11]指向一级间接数据块表头
addrs[12]指向二级简介数据块表头（doubly indirect），修改bmap，仿照原来的一级间接映射，实现二级间接映射：buf[bn/256][bn%256]
2、Symbolic links： 添加一个系统调用symlink实现软链接，对该链接文件的操作将转换为对被链接文件的操作；symlink()参数中，路径path为该文件所在路径，目标target为被链接文件的路径
可通过创建一个新的inode（类型为T_SYMLINK，即软链接），将target记录到这个inode的数据块中；同时修改sys_open，对T_SYMLINK类型进行处理，通过对inode读取数据到path中，实现符号链接，
迭代（或递归）查找被链接文件，同时定义一个递归深度，判断最终是否查找到文件主（实际拥有者）

七：thread
第七个实验展示了xv6的“多线程”实现，还有对类似于lock中锁冲突避免的哈希桶冲突避免，以及实现一个barrier来同步所有线程
1、switching between threads：实现一个用户态的线程调度，实际上在xv6中的“多线程”并非我们如今所说的那么多线程，本质上依旧是多个线程运行在一个CPU上，同时也没有通过类似时钟中断
之类的实现，而是通过线程自己本身调用yield来调用schedule进行线程调度，xv6具体通过类似进程一样的swich（uthread_swich）来切换上下文，同时需在线程结构体thread中额外添加
context来记录返回地址和栈地址以及相关寄存器上下文，并在线程调度时调用thread_switch()切换上下文
2、在多线程情况下，如果线程0调用insert，但未插入完成时，调度了线程1调用insert，此时线程1认为的哈希桶的链表头是原来的表头（而不是线程0插入的元素），就导致切换回线程0时
发生键值对覆盖，导致数据丢失，于是通过对哈希桶上锁来避免数据丢失
3、通过条件参数来实现barrier，线程到达point时会调用barrier，直到bstate.nthread到达nthread之前（全部线程抵达），都进入睡眠队列中等待
